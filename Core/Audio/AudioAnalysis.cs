using System;
using System.Collections.Generic;
using ManagedBass;
using T3.Core.Utils;

namespace T3.Core.Audio;

/// <summary>
/// Analyze audio input from internal soundtrack or from selected Wasapi device.
/// Transforms the FFT buffer generated by BASS and generates frequency bands and peaks.
/// </summary>
public static class AudioAnalysis
{
    internal static void ProcessUpdate(float gainFactor = 1f, float decayFactor = 0.9f)
    {
        var lastTargetIndex = -1;

        lock (FrequencyBands)
        {
            for (var binIndex = 0; binIndex < FftBufferSize; binIndex++)
            {
                var gain = FftGainBuffer[binIndex] * gainFactor;
                var gainDb = gain <= 0.000001f ? float.NegativeInfinity : 20 * MathF.Log10(gain);

                var normalizedValue = gainDb.RemapAndClamp(-80, 0, 0, 1);
                FftNormalizedBuffer[binIndex] = normalizedValue;

                var bandIndex = _bandIndexForFftBinIndices[binIndex];
                if (bandIndex == NoBandIndex)
                    continue;

                if (bandIndex != lastTargetIndex)
                {
                    FrequencyBands[bandIndex] = 0;
                    lastTargetIndex = bandIndex;
                }

                FrequencyBands[bandIndex] = MathF.Max(FrequencyBands[bandIndex], normalizedValue);
            }
        }

        UpdateSlidingWindowAverages();
        
        lock (FrequencyBandPeaks)
        {
            // Update Peaks
            for (var bandIndex = 0; bandIndex < FrequencyBandCount; bandIndex++)
            {
                // Compute Attacks for AudioReaction.
                // This method lacks predictably 
                {
                    var lastPeak = FrequencyBandPeaks[bandIndex];
                    var decayed = lastPeak * decayFactor;
                    var currentValue = FrequencyBands[bandIndex];
                    var newPeak = MathF.Max(decayed, currentValue);
                    FrequencyBandPeaks[bandIndex] = newPeak;
                    
                    const float attackAmplification = 4;
                    var newAttack = (newPeak - lastPeak).Clamp(0, 10000) * attackAmplification;
                    var lastAttackDecayed = FrequencyBandAttacks[bandIndex] * decayFactor;
                    FrequencyBandAttacks[bandIndex] =  MathF.Max(newAttack, lastAttackDecayed);
                }
                
                FrequencyBandAttackPeaks[bandIndex] = MathF.Max(FrequencyBandAttackPeaks[bandIndex] * 0.995f, FrequencyBandAttacks[bandIndex]);
                
                // Compute onsets for BeatSynchronization
                {
                    var lastValue = _frequencyBandsPrevious[bandIndex];
                    var smoothed = _frequencyBandAverages[bandIndex];
                    var newValueAboveAverage = FrequencyBands[bandIndex] - smoothed;
                    _frequencyBandsPrevious[bandIndex] = newValueAboveAverage;

                    var delta = (newValueAboveAverage - lastValue).Clamp(0, 1000) * 2;
                    FrequencyBandOnSets[bandIndex] = delta;
                }
            }
        }
    }

    /// <summary>
    /// To convert the fft-buffer into a logarithmic tonal scale similar to the octaves on a keyboard
    /// we have to accumulate the fft-values into bins of increasing width. This method generated a look-up
    /// mapping between fft-value and frequency bin.
    /// </summary>
    private static int[] InitializeBandsLookupsTable()
    {
        var r = new int[FftBufferSize];
        const float lowestBandFrequency = 55;
        const float highestBandFrequency = 15000;

        var maxOctave = MathF.Log2(highestBandFrequency / lowestBandFrequency);
        for (var i = 0; i < FftBufferSize; i++)
        {
            var bandIndex = NoBandIndex;
            var freq = (float)i / FftBufferSize * (48000f / 2f);

            switch (i)
            {
                case 0:
                    break;

                // For low frequency bin we fake a direct mapping to avoid gaps
                case < 6:
                    bandIndex = i - 1;
                    break;
                default:
                {
                    var octave = MathF.Log2(freq / lowestBandFrequency);
                    var octaveNormalized = octave / maxOctave;
                    bandIndex = (int)(octaveNormalized * FrequencyBandCount);
                    if (bandIndex >= FrequencyBandCount)
                        bandIndex = NoBandIndex;
                    break;
                }
            }

            r[i] = bandIndex;
        }

        return r;
    }

    #region compute sliding window average for bins
    
    private static Queue<float>[] InitHistoryBuffers()
    {
        var r = new Queue<float>[FrequencyBandCount];
        for (var i = 0; i < FrequencyBandCount; i++)
        {
            r[i] = new Queue<float>(FrequencyBandHistoryLength);
        }

        return r;
    }

    //private const float AudioUpdatesPerFrame = (float)(60000.0 / 48000);
    private const float EstimatedAudioUpdatePeriod = 0.003f;
    private const int FrequencyBandHistoryLength = (int)(1/EstimatedAudioUpdatePeriod);
    
    private static void UpdateSlidingWindowAverages()
    {
        for (var i = 0; i < FrequencyBandCount; i++)
        {
            var currentStrength = FrequencyBands[i];
            _frequencyBandHistories[i].Enqueue(currentStrength);
            _bandStrengthSums[i] += currentStrength;

            if (_frequencyBandHistories[i].Count > FrequencyBandHistoryLength)
            {
                _bandStrengthSums[i] -= _frequencyBandHistories[i].Dequeue();
            }

            var averageStrength = 0f;
            if (_frequencyBandHistories[i].Count > 0)
            {
                averageStrength = _bandStrengthSums[i] / _frequencyBandHistories[i].Count;
            }

            _frequencyBandAverages[i] = averageStrength;
        }
    }
    
    private static readonly Queue<float>[] _frequencyBandHistories = InitHistoryBuffers();
    private static readonly float[] _bandStrengthSums = new float[FrequencyBandHistoryLength];
    private static readonly float[] _frequencyBandAverages = new float[FrequencyBandHistoryLength];
    #endregion

    
    private static readonly int[] _bandIndexForFftBinIndices = InitializeBandsLookupsTable();
    private const int NoBandIndex = -1;

    internal const int FrequencyBandCount = 32;
    public static readonly float[] FrequencyBands = new float[FrequencyBandCount];
    public static readonly float[] FrequencyBandPeaks = new float[FrequencyBandCount];

    public static readonly float[] FrequencyBandAttacks = new float[FrequencyBandCount];

    private static readonly float[] _frequencyBandsPrevious = new float[FrequencyBandCount];
    public static readonly float[] FrequencyBandAttackPeaks = new float[FrequencyBandCount];
    
    /// <summary>
    /// Used by  BeatSynchronization
    /// </summary>
    public static readonly float[] FrequencyBandOnSets = new float[FrequencyBandCount];



    /// <summary>
    /// Result of the fft analysis in gain
    /// </summary>
    public static readonly float[] FftGainBuffer = new float[FftBufferSize];

    /// <summary>
    /// Result of the fft analysis converted to db and mapped to a normalized range   
    /// </summary>
    public static readonly float[] FftNormalizedBuffer = new float[FftBufferSize];

    internal const DataFlags BassFlagForFftBufferSize = DataFlags.FFT2048;
    internal const int FftBufferSize = 1024; // For Bass DataFlags.FFT2024
}